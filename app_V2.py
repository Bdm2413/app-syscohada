import streamlit as st
import pandas as pd
import io
from fpdf import FPDF
import base64

st.set_page_config(page_title="App SYSCOHADA", page_icon="üè≥Ô∏è‚Äçüåà", layout="wide")

# Menu lat√©ral
st.sidebar.success("Menu de navigation")
menu = st.sidebar.selectbox("", ["Import Fichier", "Plan de comptes", "Grand Livre", "Balance", "Bilan", "Compte de r√©sultat", "Flux de tr√©sorerie"])
st.title("üìä :rainbow[Etats financiers SYSCOHADA]")

# Initialisation session
if "data_loaded" not in st.session_state:
    st.session_state.data_loaded = False

# Import
if menu == "Import Fichier":
    uploaded_file = st.file_uploader("üìÇ Importer le fichier Excel contenant le plan comptable et le grand livre", type=["xlsx"])
    if uploaded_file:
        try:
            plan_df = pd.read_excel(uploaded_file, sheet_name="Plan de comptes", header=0, usecols="A:G")
            gl_df = pd.read_excel(uploaded_file, sheet_name="Grand Livre", header=0, usecols="A:J")
            gl_df['Date'] = pd.to_datetime(gl_df['Date'], errors='coerce').dt.strftime('%d/%m/%Y')
            
            # Nettoyage des colonnes
            gl_df.columns = gl_df.columns.str.strip()
            plan_df.columns = plan_df.columns.str.strip()

            # Standardisation des comptes
            gl_df['Compte'] = gl_df['Compte'].astype(str).str.strip().str.replace(r"\.0$", "", regex=True)
            plan_df['Compte'] = plan_df['Compte'].astype(str).str.strip().str.replace(r"\.0$", "", regex=True)

            st.session_state.plan_df = plan_df
            st.session_state.gl_df = gl_df
            st.session_state.data_loaded = True
            st.success("‚úÖ Fichier import√© avec succ√®s.")
        except Exception as e:
            st.error(f"‚ùå Erreur lors de la lecture du fichier : {e}")

# Plan de comptes
elif menu == "Plan de comptes":
    st.title("Plan de comptes")
    if not st.session_state.data_loaded:
        st.warning("üìÇ Veuillez importer un fichier d'abord.")
    else:
        st.subheader("üìö Plan de comptes - Liste des comptes")
        st.dataframe(st.session_state.plan_df, use_container_width=True)

# Grand Livre
elif menu == "Grand Livre":
    st.title("Grand Livre")
    if not st.session_state.data_loaded:
        st.warning("üìÇ Veuillez importer un fichier d'abord.")
    else:
        st.subheader("üìö Grand Livre - √âcritures comptables")

        # Copier le DataFrame
        gl_df = st.session_state.gl_df.copy()

        # Convertir la colonne Date
        if "Date" in gl_df.columns:
            gl_df["Date"] = pd.to_datetime(gl_df["Date"], format='%d/%m/%Y', errors='coerce')
            gl_df["Date_formatee"] = gl_df["Date"].dt.strftime('%d/%m/%Y')
            gl_df["Ann√©e"] = gl_df["Date"].dt.year
            gl_df["Mois"] = gl_df["Date"].dt.strftime("%Y%m")

        # Convertir la colonne 'Ann√©e' en entier pour enlever la partie d√©cimale
        gl_df["Ann√©e"] = gl_df["Ann√©e"].fillna(0).astype(int)

        # Remplir les valeurs manquantes dans D√©bit et Cr√©dit
        for col in ["D√©bit", "Cr√©dit"]:
            if col in gl_df.columns:
                gl_df[col] = pd.to_numeric(gl_df[col], errors="coerce").fillna(0)

        # Filtres
        st.sidebar.header("üßÆ Filtres")

        journal_filter = st.sidebar.multiselect("Journal", options=gl_df["Journal"].dropna().unique())
        an_filter = st.sidebar.multiselect("AN", options=gl_df["AN"].dropna().unique())
        compte_filter = st.sidebar.multiselect("Compte", options=gl_df["Compte"].dropna().unique())
        annee_filter = st.sidebar.multiselect("Ann√©e", options=sorted(gl_df["Ann√©e"].dropna().unique()))
        mois_filter = st.sidebar.multiselect("Mois", options=sorted(gl_df["Mois"].dropna().unique()))

        if journal_filter:
            gl_df = gl_df[gl_df["Journal"].isin(journal_filter)]
        if an_filter:
            gl_df = gl_df[gl_df["AN"].isin(an_filter)]
        if compte_filter:
            gl_df = gl_df[gl_df["Compte"].isin(compte_filter)]
        if annee_filter:
            gl_df = gl_df[gl_df["Ann√©e"].isin(annee_filter)]
        if mois_filter:
            gl_df = gl_df[gl_df["Mois"].isin(mois_filter)]

        # Calculs
        total_debit = gl_df["D√©bit"].sum()
        total_credit = gl_df["Cr√©dit"].sum()
        difference = total_debit - total_credit

        # Observation
        if difference == 0:
            interpretation = "RAS"
            bg_color = "#FF595E"
        elif difference > 0:
            interpretation = "Solde D√©biteur"
            bg_color = "#FF595E"
        else:
            interpretation = "Solde Cr√©diteur"
            bg_color = "#FF595E"

        # Styles
        styles = {
            "debit": "#1982C4",
            "credit": "#013026",
            "diff": "#162A2C",
            "obs": "#FF595E"
        }

        def format_int(val):
            return f"{int(val):,}".replace(",", " ")

        # Affichage des cartes
        col1, col2, col3, col4 = st.columns(4)

        with col1:
            st.markdown(f"""
                <div style="background-color:{styles['debit']}; padding:20px; border-radius:10px; text-align:center; height:110px;">
                    <div style="color:white; font-size:16px;">Total D√©bit</div>
                    <div style="color:white; font-size:24px; font-weight:bold; margin-top:10px;">{format_int(total_debit)}</div>
                </div>
            """, unsafe_allow_html=True)

        with col2:
            st.markdown(f"""
                <div style="background-color:{styles['credit']}; padding:20px; border-radius:10px; text-align:center; height:110px;">
                    <div style="color:white; font-size:16px;">Total Cr√©dit</div>
                    <div style="color:white; font-size:24px; font-weight:bold; margin-top:10px;">{format_int(total_credit)}</div>
                </div>
            """, unsafe_allow_html=True)

        with col3:
            st.markdown(f"""
                <div style="background-color:{styles['diff']}; padding:20px; border-radius:10px; text-align:center; height:110px;">
                    <div style="color:white; font-size:16px;">Solde</div>
                    <div style="color:white; font-size:24px; font-weight:bold; margin-top:10px;">{format_int(difference)}</div>
                </div>
            """, unsafe_allow_html=True)

        with col4:
            st.markdown(f"""
                <div style="background-color:{styles['obs']}; padding:20px; border-radius:10px; text-align:center; height:110px;">
                    <div style="color:white; font-size:16px;">Observations</div>
                    <div style="color:white; font-size:20px; font-weight:bold; margin-top:10px;">{interpretation}</div>
                </div>
            """, unsafe_allow_html=True)

        # Espacement
        st.markdown("<br>", unsafe_allow_html=True)

        # Formater les colonnes D√©bit / Cr√©dit pour affichage
        gl_df["D√©bit"] = gl_df["D√©bit"].apply(lambda x: format_int(x))
        gl_df["Cr√©dit"] = gl_df["Cr√©dit"].apply(lambda x: format_int(x))

        colonnes_affichage = ["Date_formatee", "Journal", "AN", "Compte", "Libell√©", "D√©bit", "Cr√©dit"]
        colonnes_presentes = [col for col in colonnes_affichage if col in gl_df.columns]

        # Tableau
        st.dataframe(gl_df[colonnes_presentes], use_container_width=True)

# Balance
elif menu == "Balance":
    st.title("Balance √† 8 colonnes")
    if not st.session_state.data_loaded:
        st.warning("üìÇ Veuillez d'abord importer un fichier Excel via le menu 'Import Fichier'.")
    else:
        plan_df = st.session_state.plan_df
        gl_df = st.session_state.gl_df

        # V√©rification colonne Ann√©e
        if "Ann√©e" not in gl_df.columns:
            st.warning("‚ùó La colonne 'Ann√©e' n'a pas √©t√© trouv√©e automatiquement.")
            annee_col = st.selectbox("S√©lectionnez la colonne correspondant √† l'ann√©e :", gl_df.columns)
        else:
            annee_col = "Ann√©e"

        # Nettoyage et conversion
        gl_df['D√©bit'] = pd.to_numeric(gl_df['D√©bit'], errors='coerce').fillna(0)
        gl_df['Cr√©dit'] = pd.to_numeric(gl_df['Cr√©dit'], errors='coerce').fillna(0)
        gl_df['AN'] = gl_df['AN'].fillna("NON")

        # Sidebar : Filtres
        annees = sorted([int(a) for a in gl_df[annee_col].dropna().unique()])
        annee_choisie = st.sidebar.selectbox("üìÖ Choisir l'ann√©e", annees)

        tableaux = sorted(plan_df['Tableau'].dropna().unique())
        tableaux_choisis = st.sidebar.multiselect("üè∑Ô∏è Choisir les tableaux", tableaux, default=tableaux)

        classes = sorted(plan_df['Compte'].astype(str).str[0].unique())
        classes_choisies = st.sidebar.multiselect("üè∑Ô∏è Choisir les classes de comptes", classes, default=classes)

        # Filtres appliqu√©s
        comptes_classes = plan_df[plan_df['Compte'].astype(str).str[0].isin(classes_choisies)]
        comptes_tableaux = comptes_classes[comptes_classes['Tableau'].isin(tableaux_choisis)]
        gl_df = gl_df[gl_df['Compte'].isin(comptes_tableaux['Compte'])]

        gl_annee = gl_df[gl_df[annee_col] == annee_choisie]
        gl_si = gl_annee[gl_annee['AN'].str.upper() == 'OUI']
        gl_mouv = gl_annee[gl_annee['AN'].str.upper() != 'OUI']

        def aggregate(df, col_name):
            return df.groupby('Compte')[[col_name]].sum().rename(columns={col_name: col_name})

        si_debit = aggregate(gl_si, 'D√©bit')
        si_credit = aggregate(gl_si, 'Cr√©dit')
        mouv_debit = aggregate(gl_mouv, 'D√©bit')
        mouv_credit = aggregate(gl_mouv, 'Cr√©dit')

        balance = comptes_tableaux.set_index('Compte').copy()
        balance = balance.join(si_debit.rename(columns={"D√©bit": "SI D√©bit"}), how="left")
        balance = balance.join(si_credit.rename(columns={"Cr√©dit": "SI Cr√©dit"}), how="left")
        balance = balance.join(mouv_debit.rename(columns={"D√©bit": "Mouv D√©bit"}), how="left")
        balance = balance.join(mouv_credit.rename(columns={"Cr√©dit": "Mouv Cr√©dit"}), how="left")

        for col in ["SI D√©bit", "SI Cr√©dit", "Mouv D√©bit", "Mouv Cr√©dit"]:
            balance[col] = balance[col].fillna(0)

        balance["SF D√©bit"] = (balance["SI D√©bit"] + balance["Mouv D√©bit"] - balance["SI Cr√©dit"] - balance["Mouv Cr√©dit"]).apply(lambda x: x if x > 0 else 0)
        balance["SF Cr√©dit"] = (balance["SI Cr√©dit"] + balance["Mouv Cr√©dit"] - balance["SI D√©bit"] - balance["Mouv D√©bit"]).apply(lambda x: x if x > 0 else 0)

        # Colonnes BD, BC, RD, RC doivent exister m√™me si vides
        for col in ["BD", "BC", "RD", "RC"]:
            if col not in balance.columns:
                balance[col] = ""

        # Nouvelle colonne : Code Bilan
        balance["Code Bilan"] = balance.apply(
            lambda row: row["BD"] if row["Tableau"] == "Bilan" and row["SF D√©bit"] > 0 else
                        row["BC"] if row["Tableau"] == "Bilan" and row["SF Cr√©dit"] > 0 else "", axis=1
        )

        # Nouvelle colonne : Code R√©sultat
        balance["Code R√©sultat"] = balance.apply(
            lambda row: row["RD"] if row["Tableau"] == "R√©sultat" and row["SF D√©bit"] > 0 else
                        row["RC"] if row["Tableau"] == "R√©sultat" and row["SF Cr√©dit"] > 0 else "", axis=1
        )

        balance = balance.reset_index()

        colonnes = ["Compte", "Intitul√©", "Tableau", "BD", "BC", "RD", "RC",
                    "SI D√©bit", "SI Cr√©dit", "Mouv D√©bit", "Mouv Cr√©dit", "SF D√©bit", "SF Cr√©dit",
                    "Code Bilan", "Code R√©sultat"]

        # Totaux
        totaux = balance[colonnes[7:13]].sum(numeric_only=True).to_dict()
        total_row = {
            "Compte": "Total", "Intitul√©": "", "Tableau": "", "BD": "", "BC": "", "RD": "", "RC": "",
            "Code Bilan": "", "Code R√©sultat": ""
        }
        total_row.update({col: round(totaux.get(col, 0), 2) for col in colonnes[7:13]})
        balance_with_total = balance[colonnes].copy()
        balance_with_total.loc[len(balance_with_total)] = total_row

        # Format montant
        def format_int(val):
            try:
                return f"{int(val):,}".replace(",", " ")
            except:
                return val

        for col in ["SI D√©bit", "SI Cr√©dit", "Mouv D√©bit", "Mouv Cr√©dit", "SF D√©bit", "SF Cr√©dit"]:
            balance_with_total[col] = balance_with_total[col].apply(lambda x: format_int(x))

        # Affichage
        st.dataframe(balance_with_total, use_container_width=True)

        # Export Excel : toutes classes
        output_excel_all_classes = io.BytesIO()
        with pd.ExcelWriter(output_excel_all_classes, engine='xlsxwriter') as writer:
            balance_with_total.to_excel(writer, index=False, sheet_name='Balance_Toutes_Classes')

        st.download_button(
            label="üì• T√©l√©charger Excel (toutes les classes)",
            data=output_excel_all_classes.getvalue(),
            file_name=f"balance_toutes_classes_{annee_choisie}.xlsx",
            mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
        )

        # Export Excel : s√©par√© par classes
        output_excel_separated_classes = io.BytesIO()
        with pd.ExcelWriter(output_excel_separated_classes, engine='xlsxwriter') as writer:
            for classe in classes_choisies:
                classe_df = balance_with_total[balance_with_total['Compte'].str.startswith(classe)]
                classe_df.to_excel(writer, index=False, sheet_name=f'Classe_{classe}')

        st.download_button(
            label="üì• T√©l√©charger Excel (s√©par√© par classes)",
            data=output_excel_separated_classes.getvalue(),
            file_name=f"balance_separee_classes_{annee_choisie}.xlsx",
            mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
        )
        # √Ä la fin du bloc "Balance"
        if "balance_par_annee" not in st.session_state:
            st.session_state.balance_par_annee = {}

        # On enregistre la balance de l'ann√©e s√©lectionn√©e dans la session
        st.session_state.balance_par_annee[annee_choisie] = balance_with_total.copy()


# Structures des bilans
structure_bilan_actif = [
    {"code": "AD", "libelle": "IMMOBILISATIONS INCORPORELLES"},
    {"code": "AE", "libelle": "Frais de d√©veloppement et de prospection"},
    {"code": "AF", "libelle": "Brevets, licences, logiciels et droits similaires"},
    {"code": "AG", "libelle": "Fonds commercial et droit au bail"},
    {"code": "AH", "libelle": "Autres immobilisations incorporelles"},
    {"code": "AI", "libelle": "IMMOBILISATIONS CORPORELLES"},
    {"code": "AJ", "libelle": "Terrains"},
    {"code": "AK", "libelle": "B√¢timents"},
    {"code": "AL", "libelle": "Am√©nagements, agencements et installations"},
    {"code": "AM", "libelle": "Mat√©riel, mobilier et actifs biologiques"},
    {"code": "AN", "libelle": "Mat√©riel de transport"},
    {"code": "AP", "libelle": "AVANCES ET ACOMPTES VERSES SUR IMMOBILISATIONS"},
    {"code": "AQ", "libelle": "IMMOBILISATIONS FINANCI√àRES"},
    {"code": "AR", "libelle": "Titres de participation"},
    {"code": "AS", "libelle": "Autres immobilisations financi√®res"},
    {"code": "AZ", "libelle": "TOTAL ACTIF IMMOBILIS√â"},
    {"code": "BA", "libelle": "ACTIF CIRCULANT HAO"},
    {"code": "BB", "libelle": "STOCKS ET ENCOURS"},
    {"code": "BG", "libelle": "CR√âANCES ET EMPLOIS ASSIMIL√âS"},
    {"code": "BH", "libelle": "Fournisseurs avances vers√©es"},
    {"code": "BI", "libelle": "Clients"},
    {"code": "BJ", "libelle": "Autres cr√©ances"},
    {"code": "BK", "libelle": "TOTAL ACTIF CIRCULANT"},
    {"code": "BQ", "libelle": "Titres de placement"},
    {"code": "BR", "libelle": "Valeurs √† encaisser"},
    {"code": "BS", "libelle": "Banques, ch√®ques postaux, caisse et assimil√©s"},
    {"code": "BT", "libelle": "TOTAL TR√âSORERIE-ACTIF"},
    {"code": "BU", "libelle": "√âcart de conversion-Actif"},
    {"code": "BZ", "libelle": "TOTAL ACTIF"}
]

structure_bilan_passif = [
    {"code": "CA", "libelle": "Capital"},
    {"code": "CB", "libelle": "Apporteurs capital non appel√© (-)"},
    {"code": "CD", "libelle": "Primes li√©es au capital social"},
    {"code": "CE", "libelle": "√âcarts de r√©√©valuation"},
    {"code": "CF", "libelle": "R√©serves indisponibles"},
    {"code": "CG", "libelle": "R√©serves libres"},
    {"code": "CH", "libelle": "Report √† nouveau (+ ou -)"},
    {"code": "CJ", "libelle": "R√©sultat net de l'exercice (b√©n√©fice + ou perte -)"},
    {"code": "CL", "libelle": "Subventions d'investissement"},
    {"code": "CM", "libelle": "Provisions r√©glement√©es"},
    {"code": "CP", "libelle": "TOTAL CAPITAUX PROPRES ET RESSOURCES ASSIMIL√âES"},
    {"code": "DA", "libelle": "Emprunts et dettes financi√®res diverses"},
    {"code": "DB", "libelle": "Dettes de location-acquisition"},
    {"code": "DC", "libelle": "Provisions pour risques et charges"},
    {"code": "DD", "libelle": "TOTAL DETTES FINANCI√àRES ET RESSOURCES ASSIMIL√âES"},
    {"code": "DF", "libelle": "TOTAL RESSOURCES STABLES"},
    {"code": "DH", "libelle": "Dettes circulantes HAO"},
    {"code": "DI", "libelle": "Clients, avances re√ßues"},
    {"code": "DJ", "libelle": "Fournisseurs d'exploitation"},
    {"code": "DK", "libelle": "Dettes fiscales et sociales"},
    {"code": "DM", "libelle": "Autres dettes"},
    {"code": "DN", "libelle": "Provisions pour risques et charges √† court terme"},
    {"code": "DP", "libelle": "TOTAL PASSIF CIRCULANT"},
    {"code": "DQ", "libelle": "Banques, cr√©dits d'escompte"},
    {"code": "DR", "libelle": "Banques, √©tablissements financiers et cr√©dits de tr√©sorerie"},
    {"code": "DT", "libelle": "TOTAL TR√âSORERIE-PASSIF"},
    {"code": "DV", "libelle": "√âcart de conversion-Passif"},
    {"code": "DZ", "libelle": "TOTAL PASSIF"}
]

def bilan():
    st.sidebar.subheader("Filtres Bilan")
    annees_balance = st.session_state.gl_df["Ann√©e"].dropna().unique().astype(int)
    annee_n = st.sidebar.selectbox("Ann√©e N", sorted(annees_balance, reverse=True))
    annee_n1 = st.sidebar.selectbox("Ann√©e N-1", sorted(annees_balance, reverse=True), index=1 if len(annees_balance) > 1 else 0)

    st.title("Bilan")

    # Fonction pour construire le bilan √† partir de la structure et de la balance
    def build_bilan_df(structure, balance, annee, colonne_label):
        df = pd.DataFrame(structure)
        df[colonne_label] = ""

        for idx, row in df.iterrows():
            code = row["code"]
            # Filtrer les lignes de la balance correspondant √† ce code bilan
            lignes_code = balance[balance["Code Bilan"] == code]

            # Convertir les colonnes SF en num√©rique (si ce n'est pas d√©j√† fait)
            lignes_code["SF D√©bit"] = pd.to_numeric(lignes_code["SF D√©bit"], errors="coerce").fillna(0)
            lignes_code["SF Cr√©dit"] = pd.to_numeric(lignes_code["SF Cr√©dit"], errors="coerce").fillna(0)

            montant = lignes_code["SF D√©bit"].sum() + lignes_code["SF Cr√©dit"].sum()
            if montant != 0:
                df.at[idx, colonne_label] = f"{int(montant):,}".replace(",", " ")

        return df

    if "balance_par_annee" not in st.session_state:
        st.warning("Veuillez d'abord g√©n√©rer une balance pour que les donn√©es soient disponibles.")
        return

    # R√©cup√©rer la balance compl√®te (filtr√©e par classes et tableaux) depuis la session
    balance_dict = st.session_state.balance_par_annee  # Cl√© : ann√©e, Valeur : DataFrame balance
    balance_n = balance_dict.get(annee_n)
    balance_n1 = balance_dict.get(annee_n1)

    if balance_n is None or balance_n1 is None:
        st.warning("Balance non disponible pour l'une des ann√©es s√©lectionn√©es.")
        return

    # G√©n√©rer les deux bilans
    df_actif = build_bilan_df(structure_bilan_actif, balance_n, annee_n, "Ann√©e N")
    df_actif = build_bilan_df(structure_bilan_actif, balance_n1, annee_n1, "Ann√©e N-1")

    df_passif = build_bilan_df(structure_bilan_passif, balance_n, annee_n, "Ann√©e N")
    df_passif = build_bilan_df(structure_bilan_passif, balance_n1, annee_n1, "Ann√©e N-1")

    # Affichage
    st.subheader("Bilan Actif")
    st.dataframe(df_actif, hide_index=True, use_container_width=True)

    st.subheader("Bilan Passif")
    st.dataframe(df_passif, hide_index=True, use_container_width=True)